.. _programming-guide-game:

In-depth game example
=====================

This tutorial will walk you through the steps of writing a simple Asteroids clone.
It is assumed that the reader is familiar with writing and running Python programs.  This
is not a programming tutorial, but it should hopefully be clear enough to follow even if
you're a beginner.  If you get stuck, first have a look at the relevant sections of the
programming guide.  The full source code can also be found in the `examples/game/` folder
of the pyglet source directory, which you can follow along with.  If anything is still not
clear, let us know!


Basic graphics
--------------

Lets begin!  The first version of our game will simply show a score of zero, a label
showing the name of the program, three randomly placed asteroids, and the player’s ship.
Nothing will move.

Setting up
^^^^^^^^^^

First things first, make sure you have pyglet installed.  Then, we will set up the folder
structure for our project.  Since this example game is written in stages, we will have several
`version` folders at various stages of development.  We will also have a shared resource folder
with the images, called ‘resources,’ outside of the example folders.  Each `version` folder
contains a Python file called `asteroid.py` which runs the game, as well as a sub-folder named
`game` where we will place additional modules; this is where most of the logic will be.
Your folder structure should look like this::

    game/
        resources/
            (images go here)
        version1/
            asteroid.py
            game/
                __init__.py

Getting a window
^^^^^^^^^^^^^^^^

To set up a window, simply `import pyglet`, create a new instance of :class:`pyglet.window.Window`,
and call `pyglet.app.run()`.:

    import pyglet
    game_window = pyglet.window.Window()

    if __name__ == '__main__':
        pyglet.app.run()

If you run the code above, you should see a window full of junk that goes away when
you press Esc.  (What you are seeing is raw uninitialized graphics memory).

Loading and displaying an image
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since our images will reside in a directory other than the example’s root directory,
we need to tell pyglet where to find them::

    import pyglet
    pyglet.resource.path = ['../resources']
    pyglet.resource.reindex()

pyglet's :mod:`pyglet.resource` module takes all of the hard work out of finding and loading
game resources such as images, sounds, etc..  All that you need to do is tell it where to look,
and reindex it.  In this example game, the resource path starts with `../` because the resources
folder is on the same level as the `version1` folder.  If we left it off, pyglet would look inside
`version1/` for the `resources/` folder.

Now that pyglet’s resource module is initialized, we can easily load the images with the
:func:`~pyglet.resource.image` function of the resource module::

    player_image = pyglet.resource.image("player.png")
    bullet_image = pyglet.resource.image("bullet.png")
    asteroid_image = pyglet.resource.image("asteroid.png")

Centering the images
^^^^^^^^^^^^^^^^^^^^

Pyglet will draw and position all images from their lower left corner by default.  We don’t
want this behavior for our images, which need to rotate around their centers.  All we have to
do to achieve this is to set their anchor points.  Lets create a function to simplify this::

    def center_image(image):
        """Sets an image's anchor point to its center"""
        image.anchor_x = image.width // 2
        image.anchor_y = image.height // 2

Now we can just call center_image() on all of our loaded images::

    center_image(player_image)
    center_image(bullet_image)
    center_image(asteroid_image)

Remember that the center_image() function must be defined before it can be called at the
module level.  Also, note that zero degrees points directly to the right in pyglet, so the
images are all drawn with their front pointing to the right.

To access the images from asteroid.py, we need to use something like
`from game import resources`, which we’ll get into in the next section.

Initializing objects
^^^^^^^^^^^^^^^^^^^^

We want to put some labels at the top of the window to give the player some information about
the score and the current difficulty level.  Eventually, we will have a score display, the name
of the level, and a row of icons representing the number of remaining lives.

Making the labels
^^^^^^^^^^^^^^^^^

To make a text label in pyglet, just initialize a :class:`pyglet.text.Label` object::

    score_label = pyglet.text.Label(text="Score: 0", x=10, y=575)
    level_label = pyglet.text.Label(text="My Amazing Game",
                                    x=400, y=575, anchor_x='center')

Notice that the second label is centered using the anchor_x attribute.

Drawing the labels
^^^^^^^^^^^^^^^^^^

We want pyglet to run some specific code whenever the window is drawn.
An :meth:`~pyglet.window.Window.on_draw` event is dispatched to the window to
give it a chance to redraw its contents.  pyglet provides several ways to attach
event handlers to objects; a simple way is to use a decorator::

    @game_window.event
    def on_draw():
        # draw things here

The `@game_window.event` decorator lets the Window instance know that our `on_draw()`
function is an event handler.  The :meth:`~pyglet.window.Window.on_draw` event is fired
whenever - you guessed it - the window needs to be redrawn.  Other events include
:meth:`~pyglet.window.Window.on_mouse_press` and :meth:`~pyglet.window.Window.on_key_press`.

Now we can fill the method with the functions necessary to draw our labels.
Before we draw anything, we should clear the screen.  After that, we can simply call each
object’s draw() function.:

    @game_window.event
    def on_draw():
        game_window.clear()

        level_label.draw()
        score_label.draw()

Now when you run asteroid.py, you should get a window with a score of zero in the upper left
corner and a centered label reading “Version 1: Static Graphics” at the top of the screen.

Making the player and asteroid sprites
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The player should be an instance or subclass of :class:`pyglet.sprite.Sprite`, like so::

    from game import resources
    ...
    player_ship = pyglet.sprite.Sprite(img=resources.player_image, x=400, y=300)

To get the player to draw on the screen, add a line to `on_draw()`::

    @game_window.event
    def on_draw():
        ...
        player_ship.draw()

Loading the asteroids is a little more complicated, since we’ll need to place more than one
at random locations that don’t immediately collide with the player.  Let’s put the loading code
in a new game submodule called load.py::

    import pyglet
    import random
    from . import resources

    def asteroids(num_asteroids):
        asteroids = []
        for i in range(num_asteroids):
            asteroid_x = random.randint(0, 800)
            asteroid_y = random.randint(0, 600)
            new_asteroid = pyglet.sprite.Sprite(img=resources.asteroid_image,
                                                x=asteroid_x, y=asteroid_y)
            new_asteroid.rotation = random.randint(0, 360)
            asteroids.append(new_asteroid)
        return asteroids

All we are doing here is making a few new sprites with random positions.  There’s still a problem,
though - an asteroid might randomly be placed exactly where the player is, causing immediate death.
To fix this issue, we’ll need to be able to tell how far away new asteroids are from the player.
Here is a simple function to calculate that distance::

    import math
    ...
    def distance(point_1=(0, 0), point_2=(0, 0)):
        """Returns the distance between two points"""
        return math.sqrt(point_1[0] - point_2[0]) ** 2 + (point_1[1] - point_2[1]) ** 2)

To check new asteroids against the player’s position, we need to pass the player’s position
into the `asteroids()` function and keep regenerating new coordinates until the asteroid is
far enough away.  pyglet sprites keep track of their position both as a tuple (Sprite.position)
and as x and y attributes (Sprite.x and Sprite.y).  To keep our code short, we’ll just pass the
position tuple into the function.:

    def asteroids(num_asteroids, player_position):
        asteroids = []
        for i in range(num_asteroids):
            asteroid_x, asteroid_y = player_position
            while distance((asteroid_x, asteroid_y), player_position) < 100:
                asteroid_x = random.randint(0, 800)
                asteroid_y = random.randint(0, 600)
            new_asteroid = pyglet.sprite.Sprite(
                img=resources.asteroid_image, x=asteroid_x, y=asteroid_y)
            new_asteroid.rotation = random.randint(0, 360)
            asteroids.append(new_asteroid)
        return asteroids

For each asteroid, it chooses random positions until it finds one away from the player,
creates the sprite, and gives it a random rotation.  Each asteroid is appended to a list,
which is returned.

Now you can load three asteroids like this::

    from game import resources, load
    ...
    asteroids = load.asteroids(3, player_ship.position)

The asteroids variable now contains a list of sprites.  Drawing them on the screen is as simple
as it was for the player’s ship - just call their :meth:~pyglet.sprite.Sprite.draw` methods.:

    @game_window.event
    def on_draw():
        ...
        for asteroid in asteroids:
            asteroid.draw()

This wraps up the first section.  Your "game" doesn't do much of anything yet, but we'll get
to that in the following sections.  You may want to look over the `examples/game/version1`
folder in the pyglet source to review what we've done, and to find a functional copy.


Basic motion
------------

In the second version of the example, we’ll introduce a simpler, faster way to draw all of the
game objects, as well as add row of icons indicating the number of lives left.  We’ll also write
some code to make the player and the asteroids obey the laws of physics.

More graphics
^^^^^^^^^^^^^

**Drawing with batches**

Calling each object’s draw() method manually can become cumbersome and tedious if there are many
different kinds of objects.  It's also very inefficient if you need to draw a large number of
objects.  The pyglet :class:`pyglet.graphics.Batch` class simplifies drawing by letting you draw
all your objects with a single function call.  All you need to do is create a batch, pass it into
each object you want to draw, and call the batch’s :meth:`~pyglet.graphics.Batch.draw` method.

To create a new batch, simply create an instance of :class:`pyglet.graphics.Batch`::

    main_batch = pyglet.graphics.Batch()

To make an object a member of a batch, just pass the batch into its constructor as the batch
keyword argument::

    score_label = pyglet.text.Label(text="Score: 0", x=10, y=575, batch=main_batch)

Add the batch keyword argument to each graphical object created in asteroid.py.

To use the batch with the asteroid sprites, we’ll need to pass the batch into the
`game.load.asteroid()` function, then just add it as a keyword argument to each new sprite.
Update the function::

    def asteroids(num_asteroids, player_position, batch=None):
        ...
        new_asteroid = pyglet.sprite.Sprite(img=resources.asteroid_image,
                                            x=asteroid_x, y=asteroid_y,
                                            batch=batch)

And update the place where it’s called::

    asteroids = load.asteroids(3, player_ship.position, main_batch)

Now you can replace those five lines of `draw()` calls with just one::

    main_batch.draw()

Now when you run asteroid.py, it should look exactly the same.

Displaying little ship icons
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To show how many lives the player has left, we’ll need to draw a little row of icons in the upper
right corner of the screen.  Since we’ll be making more than one using the same template, let’s
create a function called `player_lives()` in the `load` module to generate them.
The icons should look the same as the player’s ship.  We could create a scaled version using an
image editor, or we could just let pyglet do the scaling.  I don’t know about you, but I prefer
the option that requires less work.

The function for creating the icons is almost exactly the same as the one for creating asteroids.
For each icon we just create a sprite, give it a position and scale, and append it to the return
list.:

    def player_lives(num_icons, batch=None):
        player_lives = []
        for i in range(num_icons):
            new_sprite = pyglet.sprite.Sprite(img=resources.player_image,
                                              x=785-i*30, y=585, batch=batch)
            new_sprite.scale = 0.5
            player_lives.append(new_sprite)
        return player_lives

The player icon is 50x50 pixels, so half that size will be 25x25.  We want to put a little bit of
space between each icon, so we create them at 30-pixel intervals starting from the right side of
the screen and moving to the left.  Note that like the `asteroids()` function, `player_lives()`
takes a `batch` argument.

Making things move
^^^^^^^^^^^^^^^^^^

The game would be pretty boring if nothing on the screen ever moved.  To achieve motion, we’ll
need to write our own set of classes to handle frame-by-frame movement calculations.  We’ll also
need to write a Player class to respond to keyboard input.

**Creating the basic motion class**

Since every visible object is represented by at least one Sprite, we may as well make our basic
motion class a subclass of pyglet.sprite.Sprite.  Another approach would be to have our class
have a sprite attribute.

Create a new game submodule called physicalobject.py and declare a PhysicalObject class.
The only new attributes we’ll be adding will store the object’s velocity, so the constructor will
be simple.:

    class PhysicalObject(pyglet.sprite.Sprite):

        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)

            self.velocity_x, self.velocity_y = 0.0, 0.0

Each object will need to be updated every frame, so let’s write an `update()` method.

    def update(self, dt):
        self.x += self.velocity_x * dt
        self.y += self.velocity_y * dt

What’s dt?  It’s the "delta time", or "time step".  Game frames are not instantaneous, and
they don’t always take equal amounts of time to draw.  If you’ve ever tried to play a modern game
on an old machine, you know that frame rates can jump all over the place.  There are a number of
ways to deal with this problem, the simplest one being to just multiply all time-sensitive
operations by dt.  I’ll show you how this value is calculated later.

If we give objects a velocity and just let them go, they will fly off the screen before long.
Since we’re making an Asteroids clone, we would rather they just wrapped around the screen.
Here is a simple function that accomplishes the goal::

    def check_bounds(self):
        min_x = -self.image.width / 2
        min_y = -self.image.height / 2
        max_x = 800 + self.image.width / 2
        max_y = 600 + self.image.height / 2
        if self.x < min_x:
            self.x = max_x
        elif self.x > max_x:
            self.x = min_x
        if self.y < min_y:
            self.y = max_y
        elif self.y > max_y:
            self.y = min_y

As you can see, it simply checks to see if objects are no longer visible on the screen, and if so,
it moves them to the other side of the screen.  To make every PhysicalObject use this behavior,
add a call to `self.check_bounds()` at the end of `update()`.

To make the asteroids use our new motion code, just import the physicalobject module and change the
`new_asteroid = ...` line to create a new `PhysicalObject` instead of a `Sprite`.  You’ll also want
to give them a random initial velocity.  Here is the new, improved `load.asteroids()` function:

    def asteroids(num_asteroids, player_position, batch=None):
        ...
        new_asteroid = physicalobject.PhysicalObject(...)
        new_asteroid.rotation = random.randint(0, 360)
        new_asteroid.velocity_x = random.random()*40
        new_asteroid.velocity_y = random.random()*40
        ...

Writing the game update function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To call each object’s `update()` method every frame, we first need to have a list of those objects.
For now, we can just declare it after setting up all the other objects::

    game_objects = [player_ship] + asteroids

Now we can write a simple function to iterate over the list::

    def update(dt):
        for obj in game_objects:
            obj.update(dt)

The `update()` function takes a `dt` parameter because it is still not the source of the actual time
step.

Calling the update() function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We need to update the objects at least once per frame.  What’s a frame?  Well, most screens have a
maximum refresh rate of 60 hertz.  If we set our loop to run at exactly 60 hertz, though, the motion
will look a little jerky because it won’t match the screen exactly.  Instead, we can have it
update twice as fast, 120 times per second, to get smooth animation.

The best way to call a function 120 times per second is to ask pyglet to do it.  The
:mod:`pyglet.clock` module contains a number of ways to call functions periodically or at some
specified time in the future.  The one we want is :meth:`pyglet.clock.schedule_interval`::

    pyglet.clock.schedule_interval(update, 1/120.0)

Putting this line above `pyglet.app.run()` in the if `__name__ == '__main__'` block tells pyglet to
call `update()` 120 times per second.  Pyglet will pass in the elapsed time, i.e. `dt`, as the only
parameter.

Now when you run asteroid.py, you should see your formerly static asteroids drifting serenely
across the screen, reappearing on the other side when they slide off the edge.

Writing the Player class
^^^^^^^^^^^^^^^^^^^^^^^^

In addition to obeying the basic laws of physics, the player object needs to respond to keyboard
input.  Start by creating a `game.player` module, importing the appropriate modules, and subclassing
`PhysicalObject`::

    from . import physicalobject, resources


    class Player(physicalobject.PhysicalObject):

        def __init__(self, *args, **kwargs):
            super().__init__(img=resources.player_image, *args, **kwargs)

So far, the only difference between a Player and a PhysicalObject is that a Player will always have
the same image.  But Player objects need a couple more attributes.  Since the ship will always
thrust with the same force in whatever direction it points, we’ll need to define a constant for the
magnitude of that force.  We should also define a constant for the ship’s rotation speed.:

        self.thrust = 300.0
        self.rotate_speed = 200.0

Now we need to get the class to respond to user input.  Pyglet uses an event-based approach to
input, sending key press and key release events to registered event handlers.  But we want to use a
polling approach in this example, checking periodically if a key is down.  One way to accomplish
that is to maintain a dictionary of keys.  First, we need to initialize the dictionary in the
constructor::

        self.keys = dict(left=False, right=False, up=False)

Then we need to write two methods, `on_key_press()` and `on_key_release()`.  When pyglet checks a
new event handler, it looks for these two methods, among others.

    import math
    from pyglet.window import key
    from . import physicalobject, resources
    ...
    class Player(physicalobject.PhysicalObject)
        ...
        def on_key_press(self, symbol, modifiers):
            if symbol == key.UP:
                self.keys['up'] = True
            elif symbol == key.LEFT:
                self.keys['left'] = True
            elif symbol == key.RIGHT:
                self.keys['right'] = True

        def on_key_release(self, symbol, modifiers):
            if symbol == key.UP:
                self.keys['up'] = False
            elif symbol == key.LEFT:
                self.keys['left'] = False
            elif symbol == key.RIGHT:
                self.keys['right'] = False

That looks pretty cumbersome. There’s a better way to do it which we’ll see later, but for now,
this version serves as a good demonstration of pyglet’s event system.

The last thing we need to do is write the `update()` method.  It follows the same behavior as a
PhysicalObject plus a little extra, so we’ll need to call PhysicalObject's `update()`` method and
then respond to input.:

    def update(self, dt):
        super(Player, self).update(dt)

        if self.keys['left']:
            self.rotation -= self.rotate_speed * dt
        if self.keys['right']:
            self.rotation += self.rotate_speed * dt

Pretty simple so far.  To rotate the player, we just add the rotation speed to the angle, multiplied
by dt to account for time.  Note that Sprite objects’ rotation attributes are in degrees, with
clockwise as the positive direction.  This means that you need to call `math.degrees()` or
`math.radians()` and make the result negative whenever you use Python’s built-in math functions with
the Sprite class, since those functions use radians instead of degrees, and their positive direction
is counter-clockwise.  The code to make the ship thrust forward uses an example of such a
conversion::

        if self.keys['up']:
            angle_radians = -math.radians(self.rotation)
            force_x = math.cos(angle_radians) * self.thrust * dt
            force_y = math.sin(angle_radians) * self.thrust * dt
            self.velocity_x += force_x
            self.velocity_y += force_y

First, we convert the angle to radians so that `math.cos()` and `math.sin()` will get the correct
values.  Then we apply some simple physics to modify the ship’s X and Y velocity components and push
the ship in the right direction.

We now have a complete Player class.  If we add it to the game and tell pyglet that it’s an event
handler, we should be good to go.

Integrating the player class
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The first thing we need to do is make player_ship an instance of Player::

    from game import player
    ...
    player_ship = player.Player(x=400, y=300, batch=main_batch)

Now we need to tell pyglet that player_ship is an event handler.  To do that, we need to push it
onto the event stack with `game_window.push_handlers()`::

    game_window.push_handlers(player_ship)

That’s it! Now you should be able to run the game and move the player with the arrow keys.

Giving the player something to do
---------------------------------

To be completed!

Collision response
------------------

To be completed!

Next steps
----------

To be completed!